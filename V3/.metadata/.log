!SESSION 2021-01-12 13:53:47.759 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-12 13:54:12.215
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-12 13:54:12.216
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@166ddfb7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5da3f32a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-12 13:54:19.299
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.debug.ui 4 120 2021-01-12 16:42:02.348
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2021-01-12 17:38:48.967 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product -data file:/C:/Users/austi/OneDrive/Desktop/V3/ -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-12 17:38:51.398
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-12 17:38:51.398
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@735988cf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2d3eecda,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-12 17:38:57.028
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-12 20:58:14.880 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-12 20:58:19.955
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-12 20:58:19.955
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1fba3fd6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3aab42d6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-12 20:58:26.278
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-13 09:28:37.432 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-13 09:28:44.504
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-13 09:28:44.504
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@776e7dfb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@71418a4a,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-13 09:28:50.534
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.jobs 4 2 2021-01-13 22:30:57.631
!MESSAGE An internal error occurred during: "org.eclipse.eclemma.internal.core.launching.AgentServer".
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.eclemma.internal.ui.EclEmmaUIPlugin.getPreferenceStore()" because the return value of "org.eclipse.eclemma.internal.ui.EclEmmaUIPlugin.getInstance()" is null
	at org.eclipse.eclemma.internal.ui.UIPreferences.getPreferenceStore(UIPreferences.java:115)
	at org.eclipse.eclemma.internal.ui.UIPreferences.access$0(UIPreferences.java:114)
	at org.eclipse.eclemma.internal.ui.UIPreferences$1.getActivateNewSessions(UIPreferences.java:57)
	at org.eclipse.eclemma.internal.core.launching.AgentServer.run(AgentServer.java:123)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-01-14 09:18:05.824 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-14 09:18:16.510
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-14 09:18:16.510
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@217b0952,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3fd9e01c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-14 09:18:24.866
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-14 12:22:56.698 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-14 12:23:01.529
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-14 12:23:01.529
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@47c5cbf2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1031c1a0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-14 12:23:07.256
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-19 08:39:58.254 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-19 08:40:06.057
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-19 08:40:06.057
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@38ba8b45,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41f23499,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-19 08:40:12.573
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-20 09:04:25.327 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-20 09:04:34.583
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-20 09:04:34.583
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@41f23499,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@31dbf5bb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-20 09:04:41.636
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-20 20:14:52.360 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-20 20:15:02.911
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-20 20:15:02.911
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3fd9e01c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@36330be8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-20 20:15:13.273
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-23 13:02:40.444 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-23 13:03:44.904
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-23 13:03:44.904
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@43090195,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7921a37d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-23 13:03:51.530
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-24 09:21:50.166 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-24 09:21:58.586
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-24 09:21:58.586
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19c1f6f4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46fa2a7e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-24 09:22:05.819
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-24 19:55:17.566 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-24 19:55:26.412
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-24 19:55:26.412
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@31dbf5bb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f19d423,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-24 19:55:32.831
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-25 09:26:43.424 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-25 09:26:51.154
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-25 09:26:51.154
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1534bdc6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53079ae6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-25 09:26:57.605
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-25 11:56:44.759 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-25 11:56:49.624
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-25 11:56:49.624
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@19c1f6f4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46fa2a7e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-25 11:56:55.194
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-26 09:42:54.869 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-26 09:43:37.353
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-26 09:43:37.353
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1c0cf193,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3dd66ff5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-26 09:43:44.983
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-26 09:48:27.930 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-26 09:48:33.770
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-26 09:48:33.770
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6fc28e5b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6338afe2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-26 09:48:40.181
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2021-01-26 14:09:57.969
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Scanner;
public class Controller {
	//Instancing

	RoomPop RP = new RoomPop(10);
	Player PLAYER = new Player();
	Scanner keyboard = new Scanner(System.in);

	//Control DATA
	int CurrentRoom = 1;
	int PreviousRoom = 0;
	String userInput;
	double Rando = Math.round((Math.random() * 1));
	
	public void getInputResponse() {
		//help,Status,Grab,inventory,search,quit,use,attack,go
		userInput = keyboard.next();
		
		//Status
		if(userInput.equalsIgnoreCase("Status")) {
			PLAYER.STATUS.sayStatus();
			}
		
		//Grab
		if(userInput.equalsIgnoreCase("Grab")) {
			
			if(RP.RM[CurrentRoom].getSearched()) {
				//FlashLight
				if(RP.RM[CurrentRoom].INV.getFlashlight()) {
					PLAYER.INV.setFlashLight(true);
					RP.RM[CurrentRoom].INV.setFlashLight(false);
					System.out.println("You grab the FlashLight");
					userInput = "";
					PLAYER.INV.setEmpty(false);
					
				}
				//keys all done manually because i'm feeling lazy
				if(RP.RM[CurrentRoom].INV.K1.getInRoom()) {
					PLAYER.INV.K1.setInInventory(true);
					RP.RM[CurrentRoom].INV.K1.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K1.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K2.getInRoom()) {
					PLAYER.INV.K2.setInInventory(true);
					RP.RM[CurrentRoom].INV.K2.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K2.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K3.getInRoom()) {
					PLAYER.INV.K3.setInInventory(true);
					RP.RM[CurrentRoom].INV.K3.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K3.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K4.getInRoom()) {
					PLAYER.INV.K4.setInInventory(true);
					RP.RM[CurrentRoom].INV.K4.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K4.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K5.getInRoom()) {
					PLAYER.INV.K5.setInInventory(true);
					RP.RM[CurrentRoom].INV.K5.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K5.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K6.getInRoom()) {
					PLAYER.INV.K6.setInInventory(true);
					RP.RM[CurrentRoom].INV.K6.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K6.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Lighter	
				if(RP.RM[CurrentRoom].INV.getLighter()) {
					PLAYER.INV.setLighter(true);
					RP.RM[CurrentRoom].INV.setLighter(false);
					System.out.println("You grab the Lighter");
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Gun	
				if(RP.RM[CurrentRoom].INV.Gun.getInRoom()) {
					PLAYER.INV.Gun.setQuantity(1);
					RP.RM[CurrentRoom].INV.Gun.setInRoom(false);
					System.out.println("You grab the handgun");
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Knife	
				if(RP.RM[CurrentRoom].INV.Knife.getInRoom()) {
					PLAYER.INV.Knife.setQuantity(1);
					RP.RM[CurrentRoom].INV.Knife.setInRoom(false);
					System.out.println("You grab the knife");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Salt
				if(RP.RM[CurrentRoom].INV.Salt.getInRoom()) {
					PLAYER.INV.Salt.setQuantity(1);
					RP.RM[CurrentRoom].INV.Salt.setInRoom(false);
					System.out.println("You grab the Salt");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Religious book
				if(RP.RM[CurrentRoom].INV.ReligiousBook.getInRoom()) {
					PLAYER.INV.ReligiousBook.setQuantity(1);
					RP.RM[CurrentRoom].INV.ReligiousBook.setInRoom(false);
					System.out.println("You grab the Religious Book");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//ammo
				if(RP.RM[CurrentRoom].INV.Ammo.getInRoom()) {
					PLAYER.INV.Ammo.setQuantity(12);
					RP.RM[CurrentRoom].INV.Ammo.setInRoom(false);
					System.out.println("You grab 12 rounds of handgun ammo");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Medicine
				if(RP.RM[CurrentRoom].INV.Medicine.getInRoom()) {
					PLAYER.INV.Medicine.setQuantity(1);
					RP.RM[CurrentRoom].INV.Medicine.setInRoom(false);
					System.out.println("You grab some medicine ");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.getEmpty()== true) {
					System.out.println("There is nothing here to grab");
				}
				if(RP.RM[CurrentRoom].getSearched() == false) {
				System.out.println("You havent searched the room");
				}
				RP.RM[CurrentRoom].INV.setEmpty(true);
			}
		}
		
		//inventory
		if(userInput.equalsIgnoreCase("Inventory")) {
			PLAYER.INV.sayInventory();			
		}
		
		//search
		if(userInput.equalsIgnoreCase("Search")) {
			if(RP.RM[CurrentRoom].getLight()) {
				RP.RM[CurrentRoom].setSearched(true);
				System.out.println("You searched the room");
			}else {
				System.out.println("its too dark to look around");
			}
		}
		
		//quit
		if(userInput.equalsIgnoreCase("QUIT")) {
			System.exit(0);
		}
		
		//use
		if(userInput.equalsIgnoreCase("Use")) {
			boolean USE = true;
			
			if(PLAYER.INV.getEmpty()) {
				System.out.println("you have no items to use");
				USE = false;
				userInput = "";
			}
			while(USE){
				
				System.out.println("use what");
				userInput = keyboard.nextLine();
				
				if(userInput.equalsIgnoreCase("Flashlight")) {
					RP.RM[CurrentRoom].setLight(true);
					System.out.println("the room is now lit");
					userInput = "";
					USE = false;
				}
				if(userInput.equalsIgnoreCase("cancel")) {
					userInput = "";
					USE = false;
				}
				if(userInput.equalsIgnoreCase("key")) {
					System.out.println("use key is has been tested as true moving on to the keys...");
											
						if(PLAYER.INV.K1.getInInventory()) {
							System.out.println("k1 in inventory is true checking if it matches the door lock value");
							
						for
							if(PLAYER.INV.K1.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K1.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K2.getInInventory()) {
							System.out.println("k2 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K2.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K2.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K3.getInInventory()) {
						System.out.println("k3 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K3.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K3.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K4.getInInventory()) {
						System.out.println("k4 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K4.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K4.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K5.getInInventory()) {
						System.out.println("k5 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K5.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K5.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K6.getInInventory()) {
						System.out.println("k6 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K6.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K6.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(i == RP.RM[CurrentRoom].getNumberOfDoors() && RP.RM[CurrentRoom].DR[i].getLocked() == false){
							System.out.println("You do not have the key to unlock the door(s)");
							userInput = "";
							USE = false;
						}
					//----------------------------------------------------
					
					
					
				}
				if(userInput.equalsIgnoreCase("lighter")) {
					if(RP.RM[CurrentRoom].FP.getInRoom()) {
						
						if(PLAYER.STATUS.getSanity() >= 99) {
							System.out.println("you light the lighter but nothing happens");
						}
						if(PLAYER.STATUS.getSanity() <= 99 && RP.RM[CurrentRoom].FP.getBeenLit() == false) {
							PLAYER.STATUS.setFullSanity();
							RP.RM[CurrentRoom].FP.setBeenLit(true);
							System.out.println("you light the fireplace and you begin to feel much calmer");
						}
						if(PLAYER.STATUS.getSanity() <= 99 && RP.RM[CurrentRoom].FP.getBeenLit() == true){
							System.out.println("the room is now lightly lit. you feel more relaxed");
							PLAYER.STATUS.setSanity(5);
						}
					}
					userInput = "";
					USE = false;
				}
					
				if(userInput.equalsIgnoreCase("Gun") || userInput.equalsIgnoreCase("Knife")||
						userInput.equalsIgnoreCase("Salt")||userInput.equalsIgnoreCase("Book")||userInput.equalsIgnoreCase("Ammo") ) {
					System.out.println("now is not the time to use it");
					userInput = "";
					USE = false;
				}

				if(userInput.equalsIgnoreCase("medicine")) {
					
					if(PLAYER.STATUS.getHealth() < 100){
						PLAYER.STATUS.setHealth(PLAYER.INV.Medicine.getDamage());
						PLAYER.INV.Medicine.setQuantity(-1);
						System.out.println("you feel a bit better");
						userInput = "";
						USE = false;						
					}
					
					if(PLAYER.STATUS.getHealth()== 100) {
		 				System.out.println("now is not the time to use it");
						userInput = "";
						USE = false;
					}					
					
				}				
				
			}
  
		}
		
		
		if(userInput.equalsIgnoreCase("Attack")) {

			if(RP.RM[CurrentRoom].getNumberOfEnemies() <= 0) {
				System.out.println("there is nothing here to attack.");
			}
			
			while(RP.RM[CurrentRoom].getNumberOfEnemies() >= 1) {
				boolean Attack = true;
				boolean PlayerAttack = true;
				boolean EnemyAttack = false;
				
				Ghost GHOST = new Ghost(); //0 for ghost 
				Figure FIGURE = new Figure();//1 for figure
				System.out.println("Number of enemies in room " + RP.RM[CurrentRoom].getNumberOfEnemies());
				
				while(Attack) {					
					if(GHOST.STATUS.getHealth() <= 0) {
						RP.RM[CurrentRoom].setNumberOfEnemies(0);
						System.out.println("There are no longer enemies in the room" );
						userInput = "";
						Attack = false;
						break;
					}
					if(FIGURE.STATUS.getHealth() <= 0) {
						RP.RM[CurrentRoom].setNumberOfEnemies(0);
						System.out.println("There are no longer enemies in the room" );
						userInput = "";
						Attack = false;
						break;
					}
					if(PLAYER.STATUS.getSanity() <= 0 || PLAYER.STATUS.getHealth() <= 0) {//Game over with score printed
						
					}
					if(PlayerAttack == true) {					
						System.out.println("You begin to attack the " + RP.RM[CurrentRoom].getEnemyName() +". what do you attack with.");
						PLAYER.STATUS.sayStatus();
						userInput = keyboard.next();

							if(userInput.equalsIgnoreCase("Gun") && PLAYER.INV.Gun.getQuantity() == 1 && PLAYER.INV.Ammo.getQuantity() >=1 ) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You shoot the Ghost. However the bullet passes right through it.");
									PLAYER.INV.Ammo.setQuantity(-1);
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You shoot the Figure. The Figure lurches back in pain.");
									PLAYER.INV.Ammo.setQuantity(-1);
									FIGURE.STATUS.setHealth(PLAYER.INV.Gun.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Knife") && PLAYER.INV.Knife.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You slash at the Ghost. However nothing happens.");
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You slash at the Figure. The Figure dashes back in pain.");
									FIGURE.STATUS.setHealth(PLAYER.INV.Knife.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Salt") && PLAYER.INV.Salt.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You throw a fist full of salt at the ghost. You see it recoil in pain.");
									GHOST.STATUS.setHealth(PLAYER.INV.Salt.getDamage());
									System.out.println("Ghost HP: "+GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You throw a fist full of salt at the Figure. it barely flintches ");
									FIGURE.STATUS.setHealth(PLAYER.INV.Salt.getDamage());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Book") && PLAYER.INV.ReligiousBook.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You read from the book. The Ghost Howls in pain");
									GHOST.STATUS.setHealth(PLAYER.INV.ReligiousBook.getDamage());
									System.out.println(GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You Read from the book. The figure Paces unfazed");
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							if(userInput.equalsIgnoreCase("FingerGuns")  && PLAYER.INV.FingerGun.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You slowly make a gun with your fingers, the ghost laughs at you. as you drop the thumb hammer \nthe ghost instantly begins to shake violently and finally it gets ripped appart atom by atom");
									GHOST.STATUS.setHealth(PLAYER.INV.FingerGun.getDamage());
									System.out.println("Ghost HP: "+GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You slowly make a gun with your fingers, the figure laughs at you. as you drop the thumb hammer \nthe figure stops in its tracks, blood begins to pour from its orifaces and soon its entire body begins to colapse inward on itself as if a black hole appeared within its stomach.");
									FIGURE.STATUS.setHealth(PLAYER.INV.FingerGun.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}	
							}
							if(userInput.equalsIgnoreCase("Run")){
								
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									PLAYER.STATUS.setSanity(GHOST.INV.GhostAttack.getDamage());
									System.out.println("The Ghost Drains your sanity, but you managed to escape.");
									CurrentRoom = PreviousRoom;
									Attack = false;
									break;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									PLAYER.STATUS.setHealth(FIGURE.INV.FigureAttack.getDamage());
									System.out.println("The Figure Attacks you, but you managed to escape.");
									CurrentRoom = PreviousRoom;
									Attack = false;
									break;
								}
							}
						}
							
						while(EnemyAttack = true) {
							if(RP.RM[CurrentRoom].getEnemyType() == 0 && GHOST.STATUS.getHealth() >= 1) {
								PLAYER.STATUS.setSanity(GHOST.INV.GhostAttack.getDamage());
								System.out.println("The Ghost Drains your sanity");
								EnemyAttack = false;
								PlayerAttack = true;
							}
							if(RP.RM[CurrentRoom].getEnemyType() == 1 && FIGURE.STATUS.getHealth() >= 1) {
								PLAYER.STATUS.setHealth(FIGURE.INV.FigureAttack.getDamage());
								System.out.println("The Figure Attacks you.");
								EnemyAttack = false;
								PlayerAttack = true;
							}
							break;
						}
							
					
						
					}
					break;
				}
		}
					
				
			
	
		//Help
		if(userInput.equalsIgnoreCase("help")) {
			System.out.println("commands: help,Status,Grab,inventory,search,quit,use,attack,Go");
		}
		
		//Go
		if(userInput.equalsIgnoreCase("Go")) {
			
			if(RP.RM[CurrentRoom].getNumberOfEnemies() >= 1)
			{
				System.out.println("something blocks the door");

				
			}else {
			
			System.out.println("Go where? ");
			
			for(int i = 0; i <= RP.RM[CurrentRoom].getNumberOfDoors();i++ ) {
				System.out.println(RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.getExitValue()].getRoomDescription());	
			}
			
			//System.out.println(RP.RM[0].getRoomDescription());
			
			userInput = keyboard.nextLine();
			userInput = keyboard.nextLine();
			
			boolean Searching = true;
			while(Searching == true) {
				for (int i = 0; i < RP.AmountOfRooms;) { // for the ammount of rooms made search them all
					
					//System.out.println(userInput);
					//System.out.println("Checking "+RP.RM[i].getRoomDescription());
					if(RP.RM[i].getRoomDescription() == null) { //if there is no description, then there's probably no room so stop tryin'
						Searching = false;
						break;
					}
					if(RP.RM[i].getRoomDescription().equalsIgnoreCase(userInput)) { // testing user string room name matches the room being searched.
						
					//	System.out.println("Room Description matched true now searching door values....");
						for (int b = 0; b <= RP.RM[CurrentRoom].getNumberOfDoors();) { //if user input matches a room, then for each door in the room check each door for:
							
							//System.out.println("currently the room were searching. ( "+ RP.RM[i].getRoomDescription() + ") door being searched ( " + b +" )...");  // help debug any room issues
							//System.out.println("Now testing if ( "+ RP.RM[CurrentRoom].getRoomDescription() + " ) room Door ("+b+") to see if room ( \""+i+" "+RP.RM[i].getRoomDescription()+"\") room number matches the searched door exit value. and if room ( \""+RP.RM[i].getRoomDescription()+"\" ) door ( "+b+" ) is locked....");
							
							if(RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() == RP.RM[i].getRoomNumber() && RP.RM[CurrentRoom].DR[b].getLocked() == false) { //if our current room's door exit leads to the room were checking and if its not locked then change our current room to the new room being searched.
								System.out.println("You are at the "+RP.RM[i].getRoomDescription());
								PreviousRoom = CurrentRoom;
								CurrentRoom = RP.RM[i].getRoomNumber();
								userInput = "";
								Searching = false;
								break;
							}
						//	System.out.println("now testing if room is accessable from current location....");
							 //b == RP.RM[CurrentRoom].getNumberOfDoors() 
							if(b == RP.RM[CurrentRoom].getNumberOfDoors() && RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() != RP.RM[i].getRoomNumber()) { // if our current room, and all its doors exits dont match the room were searching, and their door exit values then we cannot go to that room from where we are.
								System.out.println("you cannot go to that room from here.");
								userInput = "";
								Searching = false;
								break;
							}
						//	System.out.println("pretty much testing what the first check was testing but now has a diffrent action if door is locked...");
							
							if(RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() == RP.RM[i].getRoomNumber() && RP.RM[CurrentRoom].DR[b].getLocked() == true) { //if our current room's door exit leads to the room were checking and if its locked then say its locked. 
								System.out.println("the room is locked");
								userInput = "";
								Searching = false;
								break;
							}
							
							 else {
						//		System.out.println("door ( "+b+" ) did not match the the room trying a new door...\n");
								b++;
							}
						}

					}else {
						i++;
						}
					}
				}
			

			}
		}
		
		//dev tools
		if(userInput.equalsIgnoreCase("DevRoomNumber")) {
			System.out.println(CurrentRoom);
			}
		if(userInput.equalsIgnoreCase("DevRoomNumberOfExits")) {
			System.out.println(RP.RM[CurrentRoom].getNumberOfDoors());
			}
		if(userInput.equalsIgnoreCase("LendLease")) {
			System.out.println("The united states government has provided you with assistance for this mission.");
			PLAYER.INV.Ammo.setQuantity(1200);
			PLAYER.INV.Medicine.setQuantity(1200);
			PLAYER.INV.Gun.setQuantity(1);
			PLAYER.INV.ReligiousBook.setQuantity(1);
			PLAYER.INV.FingerGun.setQuantity(1);
			
			}
		if(userInput.equalsIgnoreCase("lockpick")) {
			System.out.println("who wouldnt bring a lock pick to a mansion");
			PLAYER.INV.K1.setInInventory(true);
			PLAYER.INV.K2.setInInventory(true);
			PLAYER.INV.K3.setInInventory(true);
			PLAYER.INV.K4.setInInventory(true);
			PLAYER.INV.K5.setInInventory(true);
			PLAYER.INV.K6.setInInventory(true);
			PLAYER.INV.setEmpty(false);
			}
	}
	
	
	

	public void setUserInput(String UI) {
		userInput = UI;
		
	}
	public void setUpRooms() {
		RP.setAmountOfRooms(25);
		//System.out.println("Amount of rooms set to 10. Printed results: "+ RP.getAmountOfRooms());
		RP.populateRoom();
		//System.out.println("Rooms Populated. Printed results: "+ RP.RM[0].getRoomNumber()+"RoomNumber\n");
		RP.customRoomSettings();
		//System.out.println("Custom Rooms Populated. Printed results: "+ RP.RM[0].INV.Gun.getQuantity()+"Gun Quantity\n");
		
		
	}
	public void setUpCharacter() {
		Player PLAYERMAIN = new Player();
		PLAYER = PLAYERMAIN;
	}
}
	

				
			
		
	

	


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-01-26 14:09:57.976
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-01-26 14:09:57.983
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-01-26 14:09:59.496
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Scanner;
public class Controller {
	//Instancing

	RoomPop RP = new RoomPop(10);
	Player PLAYER = new Player();
	Scanner keyboard = new Scanner(System.in);

	//Control DATA
	int CurrentRoom = 1;
	int PreviousRoom = 0;
	String userInput;
	double Rando = Math.round((Math.random() * 1));
	
	public void getInputResponse() {
		//help,Status,Grab,inventory,search,quit,use,attack,go
		userInput = keyboard.next();
		
		//Status
		if(userInput.equalsIgnoreCase("Status")) {
			PLAYER.STATUS.sayStatus();
			}
		
		//Grab
		if(userInput.equalsIgnoreCase("Grab")) {
			
			if(RP.RM[CurrentRoom].getSearched()) {
				//FlashLight
				if(RP.RM[CurrentRoom].INV.getFlashlight()) {
					PLAYER.INV.setFlashLight(true);
					RP.RM[CurrentRoom].INV.setFlashLight(false);
					System.out.println("You grab the FlashLight");
					userInput = "";
					PLAYER.INV.setEmpty(false);
					
				}
				//keys all done manually because i'm feeling lazy
				if(RP.RM[CurrentRoom].INV.K1.getInRoom()) {
					PLAYER.INV.K1.setInInventory(true);
					RP.RM[CurrentRoom].INV.K1.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K1.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K2.getInRoom()) {
					PLAYER.INV.K2.setInInventory(true);
					RP.RM[CurrentRoom].INV.K2.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K2.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K3.getInRoom()) {
					PLAYER.INV.K3.setInInventory(true);
					RP.RM[CurrentRoom].INV.K3.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K3.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K4.getInRoom()) {
					PLAYER.INV.K4.setInInventory(true);
					RP.RM[CurrentRoom].INV.K4.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K4.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K5.getInRoom()) {
					PLAYER.INV.K5.setInInventory(true);
					RP.RM[CurrentRoom].INV.K5.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K5.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K6.getInRoom()) {
					PLAYER.INV.K6.setInInventory(true);
					RP.RM[CurrentRoom].INV.K6.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K6.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Lighter	
				if(RP.RM[CurrentRoom].INV.getLighter()) {
					PLAYER.INV.setLighter(true);
					RP.RM[CurrentRoom].INV.setLighter(false);
					System.out.println("You grab the Lighter");
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Gun	
				if(RP.RM[CurrentRoom].INV.Gun.getInRoom()) {
					PLAYER.INV.Gun.setQuantity(1);
					RP.RM[CurrentRoom].INV.Gun.setInRoom(false);
					System.out.println("You grab the handgun");
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Knife	
				if(RP.RM[CurrentRoom].INV.Knife.getInRoom()) {
					PLAYER.INV.Knife.setQuantity(1);
					RP.RM[CurrentRoom].INV.Knife.setInRoom(false);
					System.out.println("You grab the knife");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Salt
				if(RP.RM[CurrentRoom].INV.Salt.getInRoom()) {
					PLAYER.INV.Salt.setQuantity(1);
					RP.RM[CurrentRoom].INV.Salt.setInRoom(false);
					System.out.println("You grab the Salt");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Religious book
				if(RP.RM[CurrentRoom].INV.ReligiousBook.getInRoom()) {
					PLAYER.INV.ReligiousBook.setQuantity(1);
					RP.RM[CurrentRoom].INV.ReligiousBook.setInRoom(false);
					System.out.println("You grab the Religious Book");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//ammo
				if(RP.RM[CurrentRoom].INV.Ammo.getInRoom()) {
					PLAYER.INV.Ammo.setQuantity(12);
					RP.RM[CurrentRoom].INV.Ammo.setInRoom(false);
					System.out.println("You grab 12 rounds of handgun ammo");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Medicine
				if(RP.RM[CurrentRoom].INV.Medicine.getInRoom()) {
					PLAYER.INV.Medicine.setQuantity(1);
					RP.RM[CurrentRoom].INV.Medicine.setInRoom(false);
					System.out.println("You grab some medicine ");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.getEmpty()== true) {
					System.out.println("There is nothing here to grab");
				}
				if(RP.RM[CurrentRoom].getSearched() == false) {
				System.out.println("You havent searched the room");
				}
				RP.RM[CurrentRoom].INV.setEmpty(true);
			}
		}
		
		//inventory
		if(userInput.equalsIgnoreCase("Inventory")) {
			PLAYER.INV.sayInventory();			
		}
		
		//search
		if(userInput.equalsIgnoreCase("Search")) {
			if(RP.RM[CurrentRoom].getLight()) {
				RP.RM[CurrentRoom].setSearched(true);
				System.out.println("You searched the room");
			}else {
				System.out.println("its too dark to look around");
			}
		}
		
		//quit
		if(userInput.equalsIgnoreCase("QUIT")) {
			System.exit(0);
		}
		
		//use
		if(userInput.equalsIgnoreCase("Use")) {
			boolean USE = true;
			
			if(PLAYER.INV.getEmpty()) {
				System.out.println("you have no items to use");
				USE = false;
				userInput = "";
			}
			while(USE){
				
				System.out.println("use what");
				userInput = keyboard.nextLine();
				
				if(userInput.equalsIgnoreCase("Flashlight")) {
					RP.RM[CurrentRoom].setLight(true);
					System.out.println("the room is now lit");
					userInput = "";
					USE = false;
				}
				if(userInput.equalsIgnoreCase("cancel")) {
					userInput = "";
					USE = false;
				}
				if(userInput.equalsIgnoreCase("key")) {
					System.out.println("use key is has been tested as true moving on to the keys...");
											
						if(PLAYER.INV.K1.getInInventory()) {
							System.out.println("k1 in inventory is true checking if it matches the door lock value");
							
						for()
							if(PLAYER.INV.K1.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K1.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K2.getInInventory()) {
							System.out.println("k2 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K2.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K2.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K3.getInInventory()) {
						System.out.println("k3 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K3.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K3.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K4.getInInventory()) {
						System.out.println("k4 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K4.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K4.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K5.getInInventory()) {
						System.out.println("k5 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K5.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K5.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(PLAYER.INV.K6.getInInventory()) {
						System.out.println("k6 in inventory is true checking if it matches the door lock value");
							
							if(PLAYER.INV.K6.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K6.setInInventory(false);
								userInput = "";
								USE = false;
							}
						}
						if(i == RP.RM[CurrentRoom].getNumberOfDoors() && RP.RM[CurrentRoom].DR[i].getLocked() == false){
							System.out.println("You do not have the key to unlock the door(s)");
							userInput = "";
							USE = false;
						}
					//----------------------------------------------------
					
					
					
				}
				if(userInput.equalsIgnoreCase("lighter")) {
					if(RP.RM[CurrentRoom].FP.getInRoom()) {
						
						if(PLAYER.STATUS.getSanity() >= 99) {
							System.out.println("you light the lighter but nothing happens");
						}
						if(PLAYER.STATUS.getSanity() <= 99 && RP.RM[CurrentRoom].FP.getBeenLit() == false) {
							PLAYER.STATUS.setFullSanity();
							RP.RM[CurrentRoom].FP.setBeenLit(true);
							System.out.println("you light the fireplace and you begin to feel much calmer");
						}
						if(PLAYER.STATUS.getSanity() <= 99 && RP.RM[CurrentRoom].FP.getBeenLit() == true){
							System.out.println("the room is now lightly lit. you feel more relaxed");
							PLAYER.STATUS.setSanity(5);
						}
					}
					userInput = "";
					USE = false;
				}
					
				if(userInput.equalsIgnoreCase("Gun") || userInput.equalsIgnoreCase("Knife")||
						userInput.equalsIgnoreCase("Salt")||userInput.equalsIgnoreCase("Book")||userInput.equalsIgnoreCase("Ammo") ) {
					System.out.println("now is not the time to use it");
					userInput = "";
					USE = false;
				}

				if(userInput.equalsIgnoreCase("medicine")) {
					
					if(PLAYER.STATUS.getHealth() < 100){
						PLAYER.STATUS.setHealth(PLAYER.INV.Medicine.getDamage());
						PLAYER.INV.Medicine.setQuantity(-1);
						System.out.println("you feel a bit better");
						userInput = "";
						USE = false;						
					}
					
					if(PLAYER.STATUS.getHealth()== 100) {
		 				System.out.println("now is not the time to use it");
						userInput = "";
						USE = false;
					}					
					
				}				
				
			}
  
		}
		
		
		if(userInput.equalsIgnoreCase("Attack")) {

			if(RP.RM[CurrentRoom].getNumberOfEnemies() <= 0) {
				System.out.println("there is nothing here to attack.");
			}
			
			while(RP.RM[CurrentRoom].getNumberOfEnemies() >= 1) {
				boolean Attack = true;
				boolean PlayerAttack = true;
				boolean EnemyAttack = false;
				
				Ghost GHOST = new Ghost(); //0 for ghost 
				Figure FIGURE = new Figure();//1 for figure
				System.out.println("Number of enemies in room " + RP.RM[CurrentRoom].getNumberOfEnemies());
				
				while(Attack) {					
					if(GHOST.STATUS.getHealth() <= 0) {
						RP.RM[CurrentRoom].setNumberOfEnemies(0);
						System.out.println("There are no longer enemies in the room" );
						userInput = "";
						Attack = false;
						break;
					}
					if(FIGURE.STATUS.getHealth() <= 0) {
						RP.RM[CurrentRoom].setNumberOfEnemies(0);
						System.out.println("There are no longer enemies in the room" );
						userInput = "";
						Attack = false;
						break;
					}
					if(PLAYER.STATUS.getSanity() <= 0 || PLAYER.STATUS.getHealth() <= 0) {//Game over with score printed
						
					}
					if(PlayerAttack == true) {					
						System.out.println("You begin to attack the " + RP.RM[CurrentRoom].getEnemyName() +". what do you attack with.");
						PLAYER.STATUS.sayStatus();
						userInput = keyboard.next();

							if(userInput.equalsIgnoreCase("Gun") && PLAYER.INV.Gun.getQuantity() == 1 && PLAYER.INV.Ammo.getQuantity() >=1 ) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You shoot the Ghost. However the bullet passes right through it.");
									PLAYER.INV.Ammo.setQuantity(-1);
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You shoot the Figure. The Figure lurches back in pain.");
									PLAYER.INV.Ammo.setQuantity(-1);
									FIGURE.STATUS.setHealth(PLAYER.INV.Gun.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Knife") && PLAYER.INV.Knife.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You slash at the Ghost. However nothing happens.");
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You slash at the Figure. The Figure dashes back in pain.");
									FIGURE.STATUS.setHealth(PLAYER.INV.Knife.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Salt") && PLAYER.INV.Salt.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You throw a fist full of salt at the ghost. You see it recoil in pain.");
									GHOST.STATUS.setHealth(PLAYER.INV.Salt.getDamage());
									System.out.println("Ghost HP: "+GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You throw a fist full of salt at the Figure. it barely flintches ");
									FIGURE.STATUS.setHealth(PLAYER.INV.Salt.getDamage());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Book") && PLAYER.INV.ReligiousBook.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You read from the book. The Ghost Howls in pain");
									GHOST.STATUS.setHealth(PLAYER.INV.ReligiousBook.getDamage());
									System.out.println(GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You Read from the book. The figure Paces unfazed");
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							if(userInput.equalsIgnoreCase("FingerGuns")  && PLAYER.INV.FingerGun.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You slowly make a gun with your fingers, the ghost laughs at you. as you drop the thumb hammer \nthe ghost instantly begins to shake violently and finally it gets ripped appart atom by atom");
									GHOST.STATUS.setHealth(PLAYER.INV.FingerGun.getDamage());
									System.out.println("Ghost HP: "+GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You slowly make a gun with your fingers, the figure laughs at you. as you drop the thumb hammer \nthe figure stops in its tracks, blood begins to pour from its orifaces and soon its entire body begins to colapse inward on itself as if a black hole appeared within its stomach.");
									FIGURE.STATUS.setHealth(PLAYER.INV.FingerGun.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}	
							}
							if(userInput.equalsIgnoreCase("Run")){
								
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									PLAYER.STATUS.setSanity(GHOST.INV.GhostAttack.getDamage());
									System.out.println("The Ghost Drains your sanity, but you managed to escape.");
									CurrentRoom = PreviousRoom;
									Attack = false;
									break;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									PLAYER.STATUS.setHealth(FIGURE.INV.FigureAttack.getDamage());
									System.out.println("The Figure Attacks you, but you managed to escape.");
									CurrentRoom = PreviousRoom;
									Attack = false;
									break;
								}
							}
						}
							
						while(EnemyAttack = true) {
							if(RP.RM[CurrentRoom].getEnemyType() == 0 && GHOST.STATUS.getHealth() >= 1) {
								PLAYER.STATUS.setSanity(GHOST.INV.GhostAttack.getDamage());
								System.out.println("The Ghost Drains your sanity");
								EnemyAttack = false;
								PlayerAttack = true;
							}
							if(RP.RM[CurrentRoom].getEnemyType() == 1 && FIGURE.STATUS.getHealth() >= 1) {
								PLAYER.STATUS.setHealth(FIGURE.INV.FigureAttack.getDamage());
								System.out.println("The Figure Attacks you.");
								EnemyAttack = false;
								PlayerAttack = true;
							}
							break;
						}
							
					
						
					}
					break;
				}
		}
					
				
			
	
		//Help
		if(userInput.equalsIgnoreCase("help")) {
			System.out.println("commands: help,Status,Grab,inventory,search,quit,use,attack,Go");
		}
		
		//Go
		if(userInput.equalsIgnoreCase("Go")) {
			
			if(RP.RM[CurrentRoom].getNumberOfEnemies() >= 1)
			{
				System.out.println("something blocks the door");

				
			}else {
			
			System.out.println("Go where? ");
			
			for(int i = 0; i <= RP.RM[CurrentRoom].getNumberOfDoors();i++ ) {
				System.out.println(RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.getExitValue()].getRoomDescription());	
			}
			
			//System.out.println(RP.RM[0].getRoomDescription());
			
			userInput = keyboard.nextLine();
			userInput = keyboard.nextLine();
			
			boolean Searching = true;
			while(Searching == true) {
				for (int i = 0; i < RP.AmountOfRooms;) { // for the ammount of rooms made search them all
					
					//System.out.println(userInput);
					//System.out.println("Checking "+RP.RM[i].getRoomDescription());
					if(RP.RM[i].getRoomDescription() == null) { //if there is no description, then there's probably no room so stop tryin'
						Searching = false;
						break;
					}
					if(RP.RM[i].getRoomDescription().equalsIgnoreCase(userInput)) { // testing user string room name matches the room being searched.
						
					//	System.out.println("Room Description matched true now searching door values....");
						for (int b = 0; b <= RP.RM[CurrentRoom].getNumberOfDoors();) { //if user input matches a room, then for each door in the room check each door for:
							
							//System.out.println("currently the room were searching. ( "+ RP.RM[i].getRoomDescription() + ") door being searched ( " + b +" )...");  // help debug any room issues
							//System.out.println("Now testing if ( "+ RP.RM[CurrentRoom].getRoomDescription() + " ) room Door ("+b+") to see if room ( \""+i+" "+RP.RM[i].getRoomDescription()+"\") room number matches the searched door exit value. and if room ( \""+RP.RM[i].getRoomDescription()+"\" ) door ( "+b+" ) is locked....");
							
							if(RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() == RP.RM[i].getRoomNumber() && RP.RM[CurrentRoom].DR[b].getLocked() == false) { //if our current room's door exit leads to the room were checking and if its not locked then change our current room to the new room being searched.
								System.out.println("You are at the "+RP.RM[i].getRoomDescription());
								PreviousRoom = CurrentRoom;
								CurrentRoom = RP.RM[i].getRoomNumber();
								userInput = "";
								Searching = false;
								break;
							}
						//	System.out.println("now testing if room is accessable from current location....");
							 //b == RP.RM[CurrentRoom].getNumberOfDoors() 
							if(b == RP.RM[CurrentRoom].getNumberOfDoors() && RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() != RP.RM[i].getRoomNumber()) { // if our current room, and all its doors exits dont match the room were searching, and their door exit values then we cannot go to that room from where we are.
								System.out.println("you cannot go to that room from here.");
								userInput = "";
								Searching = false;
								break;
							}
						//	System.out.println("pretty much testing what the first check was testing but now has a diffrent action if door is locked...");
							
							if(RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() == RP.RM[i].getRoomNumber() && RP.RM[CurrentRoom].DR[b].getLocked() == true) { //if our current room's door exit leads to the room were checking and if its locked then say its locked. 
								System.out.println("the room is locked");
								userInput = "";
								Searching = false;
								break;
							}
							
							 else {
						//		System.out.println("door ( "+b+" ) did not match the the room trying a new door...\n");
								b++;
							}
						}

					}else {
						i++;
						}
					}
				}
			

			}
		}
		
		//dev tools
		if(userInput.equalsIgnoreCase("DevRoomNumber")) {
			System.out.println(CurrentRoom);
			}
		if(userInput.equalsIgnoreCase("DevRoomNumberOfExits")) {
			System.out.println(RP.RM[CurrentRoom].getNumberOfDoors());
			}
		if(userInput.equalsIgnoreCase("LendLease")) {
			System.out.println("The united states government has provided you with assistance for this mission.");
			PLAYER.INV.Ammo.setQuantity(1200);
			PLAYER.INV.Medicine.setQuantity(1200);
			PLAYER.INV.Gun.setQuantity(1);
			PLAYER.INV.ReligiousBook.setQuantity(1);
			PLAYER.INV.FingerGun.setQuantity(1);
			
			}
		if(userInput.equalsIgnoreCase("lockpick")) {
			System.out.println("who wouldnt bring a lock pick to a mansion");
			PLAYER.INV.K1.setInInventory(true);
			PLAYER.INV.K2.setInInventory(true);
			PLAYER.INV.K3.setInInventory(true);
			PLAYER.INV.K4.setInInventory(true);
			PLAYER.INV.K5.setInInventory(true);
			PLAYER.INV.K6.setInInventory(true);
			PLAYER.INV.setEmpty(false);
			}
	}
	
	
	

	public void setUserInput(String UI) {
		userInput = UI;
		
	}
	public void setUpRooms() {
		RP.setAmountOfRooms(25);
		//System.out.println("Amount of rooms set to 10. Printed results: "+ RP.getAmountOfRooms());
		RP.populateRoom();
		//System.out.println("Rooms Populated. Printed results: "+ RP.RM[0].getRoomNumber()+"RoomNumber\n");
		RP.customRoomSettings();
		//System.out.println("Custom Rooms Populated. Printed results: "+ RP.RM[0].INV.Gun.getQuantity()+"Gun Quantity\n");
		
		
	}
	public void setUpCharacter() {
		Player PLAYERMAIN = new Player();
		PLAYER = PLAYERMAIN;
	}
}
	

				
			
		
	

	


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-01-26 14:09:59.505
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-01-26 14:09:59.513
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-01-26 14:33:10.805
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Scanner;
public class Controller {
	//Instancing

	RoomPop RP = new RoomPop(10);
	Player PLAYER = new Player();
	Scanner keyboard = new Scanner(System.in);

	//Control DATA
	int CurrentRoom = 1;
	int PreviousRoom = 0;
	String userInput;
	double Rando = Math.round((Math.random() * 1));
	
	public void getInputResponse() {
		//help,Status,Grab,inventory,search,quit,use,attack,go
		userInput = keyboard.next();
		
		//Status
		if(userInput.equalsIgnoreCase("Status")) {
			PLAYER.STATUS.sayStatus();
			}
		
		//Grab
		if(userInput.equalsIgnoreCase("Grab")) {
			
			if(RP.RM[CurrentRoom].getSearched()) {
				//FlashLight
				if(RP.RM[CurrentRoom].INV.getFlashlight()) {
					PLAYER.INV.setFlashLight(true);
					RP.RM[CurrentRoom].INV.setFlashLight(false);
					System.out.println("You grab the FlashLight");
					userInput = "";
					PLAYER.INV.setEmpty(false);
					
				}
				//keys all done manually because i'm feeling lazy
				if(RP.RM[CurrentRoom].INV.K1.getInRoom()) {
					PLAYER.INV.K1.setInInventory(true);
					RP.RM[CurrentRoom].INV.K1.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K1.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K2.getInRoom()) {
					PLAYER.INV.K2.setInInventory(true);
					RP.RM[CurrentRoom].INV.K2.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K2.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K3.getInRoom()) {
					PLAYER.INV.K3.setInInventory(true);
					RP.RM[CurrentRoom].INV.K3.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K3.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K4.getInRoom()) {
					PLAYER.INV.K4.setInInventory(true);
					RP.RM[CurrentRoom].INV.K4.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K4.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K5.getInRoom()) {
					PLAYER.INV.K5.setInInventory(true);
					RP.RM[CurrentRoom].INV.K5.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K5.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K6.getInRoom()) {
					PLAYER.INV.K6.setInInventory(true);
					RP.RM[CurrentRoom].INV.K6.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K6.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Lighter	
				if(RP.RM[CurrentRoom].INV.getLighter()) {
					PLAYER.INV.setLighter(true);
					RP.RM[CurrentRoom].INV.setLighter(false);
					System.out.println("You grab the Lighter");
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Gun	
				if(RP.RM[CurrentRoom].INV.Gun.getInRoom()) {
					PLAYER.INV.Gun.setQuantity(1);
					RP.RM[CurrentRoom].INV.Gun.setInRoom(false);
					System.out.println("You grab the handgun");
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Knife	
				if(RP.RM[CurrentRoom].INV.Knife.getInRoom()) {
					PLAYER.INV.Knife.setQuantity(1);
					RP.RM[CurrentRoom].INV.Knife.setInRoom(false);
					System.out.println("You grab the knife");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Salt
				if(RP.RM[CurrentRoom].INV.Salt.getInRoom()) {
					PLAYER.INV.Salt.setQuantity(1);
					RP.RM[CurrentRoom].INV.Salt.setInRoom(false);
					System.out.println("You grab the Salt");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Religious book
				if(RP.RM[CurrentRoom].INV.ReligiousBook.getInRoom()) {
					PLAYER.INV.ReligiousBook.setQuantity(1);
					RP.RM[CurrentRoom].INV.ReligiousBook.setInRoom(false);
					System.out.println("You grab the Religious Book");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//ammo
				if(RP.RM[CurrentRoom].INV.Ammo.getInRoom()) {
					PLAYER.INV.Ammo.setQuantity(12);
					RP.RM[CurrentRoom].INV.Ammo.setInRoom(false);
					System.out.println("You grab 12 rounds of handgun ammo");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Medicine
				if(RP.RM[CurrentRoom].INV.Medicine.getInRoom()) {
					PLAYER.INV.Medicine.setQuantity(1);
					RP.RM[CurrentRoom].INV.Medicine.setInRoom(false);
					System.out.println("You grab some medicine ");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.getEmpty()== true) {
					System.out.println("There is nothing here to grab");
				}
				if(RP.RM[CurrentRoom].getSearched() == false) {
				System.out.println("You havent searched the room");
				}
				RP.RM[CurrentRoom].INV.setEmpty(true);
			}
		}
		
		//inventory
		if(userInput.equalsIgnoreCase("Inventory")) {
			PLAYER.INV.sayInventory();			
		}
		
		//search
		if(userInput.equalsIgnoreCase("Search")) {
			if(RP.RM[CurrentRoom].getLight()) {
				RP.RM[CurrentRoom].setSearched(true);
				System.out.println("You searched the room");
			}else {
				System.out.println("its too dark to look around");
			}
		}
		
		//quit
		if(userInput.equalsIgnoreCase("QUIT")) {
			System.exit(0);
		}
		
		//use
		if(userInput.equalsIgnoreCase("Use")) {
			boolean USE = true;
			
			if(PLAYER.INV.getEmpty()) {
				System.out.println("you have no items to use");
				USE = false;
				userInput = "";
			}
			while(USE){
				
				System.out.println("use what");
				userInput = keyboard.nextLine();
				
				if(userInput.equalsIgnoreCase("Flashlight")) {
					RP.RM[CurrentRoom].setLight(true);
					System.out.println("the room is now lit");
					userInput = "";
					USE = false;
				}
				if(userInput.equalsIgnoreCase("cancel")) {
					userInput = "";
					USE = false;
				}
				if(userInput.equalsIgnoreCase("key")) {
					System.out.println("use key is has been tested as true moving on to the keys...");
											
					if(PLAYER.INV.K1.getInInventory()) {
						System.out.println("k1 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K1.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K1.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
					
						if(PLAYER.INV.K2.getInInventory()) {
							System.out.println("k2 in inventory is true checking if it matches the door lock value");
							
							for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
								if(PLAYER.INV.K2.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
									RP.RM[CurrentRoom].DR[i].setLocked(false);
									System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
									System.out.println("\nYou no longer need this key...");
									PLAYER.INV.K2.setInInventory(false);
									userInput = "";
									USE = false;
									}
								}
							}
						
						if(PLAYER.INV.K3.getInInventory()) {
						System.out.println("k3 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K3.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K3.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
						if(PLAYER.INV.K4.getInInventory()) {
						System.out.println("k4 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K4.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K4.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
						
						if(PLAYER.INV.K5.getInInventory()) {
						System.out.println("k5 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K5.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K5.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
						if(PLAYER.INV.K6.getInInventory()) {
						System.out.println("k6 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K6.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K6.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
for
						if(i == RP.RM[CurrentRoom].getNumberOfDoors() && RP.RM[CurrentRoom].DR[i].getLocked() == false){
							System.out.println("You do not have the key to unlock the door(s)");
							userInput = "";
							USE = false;
						}
					//----------------------------------------------------
					
					
					
				}
				if(userInput.equalsIgnoreCase("lighter")) {
					if(RP.RM[CurrentRoom].FP.getInRoom()) {
						
						if(PLAYER.STATUS.getSanity() >= 99) {
							System.out.println("you light the lighter but nothing happens");
						}
						if(PLAYER.STATUS.getSanity() <= 99 && RP.RM[CurrentRoom].FP.getBeenLit() == false) {
							PLAYER.STATUS.setFullSanity();
							RP.RM[CurrentRoom].FP.setBeenLit(true);
							System.out.println("you light the fireplace and you begin to feel much calmer");
						}
						if(PLAYER.STATUS.getSanity() <= 99 && RP.RM[CurrentRoom].FP.getBeenLit() == true){
							System.out.println("the room is now lightly lit. you feel more relaxed");
							PLAYER.STATUS.setSanity(5);
						}
					}
					userInput = "";
					USE = false;
				}
					
				if(userInput.equalsIgnoreCase("Gun") || userInput.equalsIgnoreCase("Knife")||
						userInput.equalsIgnoreCase("Salt")||userInput.equalsIgnoreCase("Book")||userInput.equalsIgnoreCase("Ammo") ) {
					System.out.println("now is not the time to use it");
					userInput = "";
					USE = false;
				}

				if(userInput.equalsIgnoreCase("medicine")) {
					
					if(PLAYER.STATUS.getHealth() < 100){
						PLAYER.STATUS.setHealth(PLAYER.INV.Medicine.getDamage());
						PLAYER.INV.Medicine.setQuantity(-1);
						System.out.println("you feel a bit better");
						userInput = "";
						USE = false;						
					}
					
					if(PLAYER.STATUS.getHealth()== 100) {
		 				System.out.println("now is not the time to use it");
						userInput = "";
						USE = false;
					}					
					
				}				
				
			}
  
		}
		
		
		if(userInput.equalsIgnoreCase("Attack")) {

			if(RP.RM[CurrentRoom].getNumberOfEnemies() <= 0) {
				System.out.println("there is nothing here to attack.");
			}
			
			while(RP.RM[CurrentRoom].getNumberOfEnemies() >= 1) {
				boolean Attack = true;
				boolean PlayerAttack = true;
				boolean EnemyAttack = false;
				
				Ghost GHOST = new Ghost(); //0 for ghost 
				Figure FIGURE = new Figure();//1 for figure
				System.out.println("Number of enemies in room " + RP.RM[CurrentRoom].getNumberOfEnemies());
				
				while(Attack) {					
					if(GHOST.STATUS.getHealth() <= 0) {
						RP.RM[CurrentRoom].setNumberOfEnemies(0);
						System.out.println("There are no longer enemies in the room" );
						userInput = "";
						Attack = false;
						break;
					}
					if(FIGURE.STATUS.getHealth() <= 0) {
						RP.RM[CurrentRoom].setNumberOfEnemies(0);
						System.out.println("There are no longer enemies in the room" );
						userInput = "";
						Attack = false;
						break;
					}
					if(PLAYER.STATUS.getSanity() <= 0 || PLAYER.STATUS.getHealth() <= 0) {//Game over with score printed
						
					}
					if(PlayerAttack == true) {					
						System.out.println("You begin to attack the " + RP.RM[CurrentRoom].getEnemyName() +". what do you attack with.");
						PLAYER.STATUS.sayStatus();
						userInput = keyboard.next();

							if(userInput.equalsIgnoreCase("Gun") && PLAYER.INV.Gun.getQuantity() == 1 && PLAYER.INV.Ammo.getQuantity() >=1 ) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You shoot the Ghost. However the bullet passes right through it.");
									PLAYER.INV.Ammo.setQuantity(-1);
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You shoot the Figure. The Figure lurches back in pain.");
									PLAYER.INV.Ammo.setQuantity(-1);
									FIGURE.STATUS.setHealth(PLAYER.INV.Gun.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Knife") && PLAYER.INV.Knife.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You slash at the Ghost. However nothing happens.");
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You slash at the Figure. The Figure dashes back in pain.");
									FIGURE.STATUS.setHealth(PLAYER.INV.Knife.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Salt") && PLAYER.INV.Salt.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You throw a fist full of salt at the ghost. You see it recoil in pain.");
									GHOST.STATUS.setHealth(PLAYER.INV.Salt.getDamage());
									System.out.println("Ghost HP: "+GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You throw a fist full of salt at the Figure. it barely flintches ");
									FIGURE.STATUS.setHealth(PLAYER.INV.Salt.getDamage());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Book") && PLAYER.INV.ReligiousBook.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You read from the book. The Ghost Howls in pain");
									GHOST.STATUS.setHealth(PLAYER.INV.ReligiousBook.getDamage());
									System.out.println(GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You Read from the book. The figure Paces unfazed");
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							if(userInput.equalsIgnoreCase("FingerGuns")  && PLAYER.INV.FingerGun.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You slowly make a gun with your fingers, the ghost laughs at you. as you drop the thumb hammer \nthe ghost instantly begins to shake violently and finally it gets ripped appart atom by atom");
									GHOST.STATUS.setHealth(PLAYER.INV.FingerGun.getDamage());
									System.out.println("Ghost HP: "+GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You slowly make a gun with your fingers, the figure laughs at you. as you drop the thumb hammer \nthe figure stops in its tracks, blood begins to pour from its orifaces and soon its entire body begins to colapse inward on itself as if a black hole appeared within its stomach.");
									FIGURE.STATUS.setHealth(PLAYER.INV.FingerGun.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}	
							}
							if(userInput.equalsIgnoreCase("Run")){
								
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									PLAYER.STATUS.setSanity(GHOST.INV.GhostAttack.getDamage());
									System.out.println("The Ghost Drains your sanity, but you managed to escape.");
									CurrentRoom = PreviousRoom;
									Attack = false;
									break;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									PLAYER.STATUS.setHealth(FIGURE.INV.FigureAttack.getDamage());
									System.out.println("The Figure Attacks you, but you managed to escape.");
									CurrentRoom = PreviousRoom;
									Attack = false;
									break;
								}
							}
						}
							
						while(EnemyAttack = true) {
							if(RP.RM[CurrentRoom].getEnemyType() == 0 && GHOST.STATUS.getHealth() >= 1) {
								PLAYER.STATUS.setSanity(GHOST.INV.GhostAttack.getDamage());
								System.out.println("The Ghost Drains your sanity");
								EnemyAttack = false;
								PlayerAttack = true;
							}
							if(RP.RM[CurrentRoom].getEnemyType() == 1 && FIGURE.STATUS.getHealth() >= 1) {
								PLAYER.STATUS.setHealth(FIGURE.INV.FigureAttack.getDamage());
								System.out.println("The Figure Attacks you.");
								EnemyAttack = false;
								PlayerAttack = true;
							}
							break;
						}
							
					
						
					}
					break;
				}
		}
					
				
			
	
		//Help
		if(userInput.equalsIgnoreCase("help")) {
			System.out.println("commands: help,Status,Grab,inventory,search,quit,use,attack,Go");
		}
		
		//Go
		if(userInput.equalsIgnoreCase("Go")) {
			
			if(RP.RM[CurrentRoom].getNumberOfEnemies() >= 1)
			{
				System.out.println("something blocks the door");

				
			}else {
			
			System.out.println("Go where? ");
			
			for(int i = 0; i <= RP.RM[CurrentRoom].getNumberOfDoors();i++ ) {
				System.out.println(RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.getExitValue()].getRoomDescription());	
			}
			
			//System.out.println(RP.RM[0].getRoomDescription());
			
			userInput = keyboard.nextLine();
			userInput = keyboard.nextLine();
			
			boolean Searching = true;
			while(Searching == true) {
				for (int i = 0; i < RP.AmountOfRooms;) { // for the ammount of rooms made search them all
					
					//System.out.println(userInput);
					//System.out.println("Checking "+RP.RM[i].getRoomDescription());
					if(RP.RM[i].getRoomDescription() == null) { //if there is no description, then there's probably no room so stop tryin'
						Searching = false;
						break;
					}
					if(RP.RM[i].getRoomDescription().equalsIgnoreCase(userInput)) { // testing user string room name matches the room being searched.
						
					//	System.out.println("Room Description matched true now searching door values....");
						for (int b = 0; b <= RP.RM[CurrentRoom].getNumberOfDoors();) { //if user input matches a room, then for each door in the room check each door for:
							
							//System.out.println("currently the room were searching. ( "+ RP.RM[i].getRoomDescription() + ") door being searched ( " + b +" )...");  // help debug any room issues
							//System.out.println("Now testing if ( "+ RP.RM[CurrentRoom].getRoomDescription() + " ) room Door ("+b+") to see if room ( \""+i+" "+RP.RM[i].getRoomDescription()+"\") room number matches the searched door exit value. and if room ( \""+RP.RM[i].getRoomDescription()+"\" ) door ( "+b+" ) is locked....");
							
							if(RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() == RP.RM[i].getRoomNumber() && RP.RM[CurrentRoom].DR[b].getLocked() == false) { //if our current room's door exit leads to the room were checking and if its not locked then change our current room to the new room being searched.
								System.out.println("You are at the "+RP.RM[i].getRoomDescription());
								PreviousRoom = CurrentRoom;
								CurrentRoom = RP.RM[i].getRoomNumber();
								userInput = "";
								Searching = false;
								break;
							}
						//	System.out.println("now testing if room is accessable from current location....");
							 //b == RP.RM[CurrentRoom].getNumberOfDoors() 
							if(b == RP.RM[CurrentRoom].getNumberOfDoors() && RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() != RP.RM[i].getRoomNumber()) { // if our current room, and all its doors exits dont match the room were searching, and their door exit values then we cannot go to that room from where we are.
								System.out.println("you cannot go to that room from here.");
								userInput = "";
								Searching = false;
								break;
							}
						//	System.out.println("pretty much testing what the first check was testing but now has a diffrent action if door is locked...");
							
							if(RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() == RP.RM[i].getRoomNumber() && RP.RM[CurrentRoom].DR[b].getLocked() == true) { //if our current room's door exit leads to the room were checking and if its locked then say its locked. 
								System.out.println("the room is locked");
								userInput = "";
								Searching = false;
								break;
							}
							
							 else {
						//		System.out.println("door ( "+b+" ) did not match the the room trying a new door...\n");
								b++;
							}
						}

					}else {
						i++;
						}
					}
				}
			

			}
		}
		
		//dev tools
		if(userInput.equalsIgnoreCase("DevRoomNumber")) {
			System.out.println(CurrentRoom);
			}
		if(userInput.equalsIgnoreCase("DevRoomNumberOfExits")) {
			System.out.println(RP.RM[CurrentRoom].getNumberOfDoors());
			}
		if(userInput.equalsIgnoreCase("LendLease")) {
			System.out.println("The united states government has provided you with assistance for this mission.");
			PLAYER.INV.Ammo.setQuantity(1200);
			PLAYER.INV.Medicine.setQuantity(1200);
			PLAYER.INV.Gun.setQuantity(1);
			PLAYER.INV.ReligiousBook.setQuantity(1);
			PLAYER.INV.FingerGun.setQuantity(1);
			
			}
		if(userInput.equalsIgnoreCase("lockpick")) {
			System.out.println("who wouldnt bring a lock pick to a mansion");
			PLAYER.INV.K1.setInInventory(true);
			PLAYER.INV.K2.setInInventory(true);
			PLAYER.INV.K3.setInInventory(true);
			PLAYER.INV.K4.setInInventory(true);
			PLAYER.INV.K5.setInInventory(true);
			PLAYER.INV.K6.setInInventory(true);
			PLAYER.INV.setEmpty(false);
			}
	}
	
	
	

	public void setUserInput(String UI) {
		userInput = UI;
		
	}
	public void setUpRooms() {
		RP.setAmountOfRooms(25);
		//System.out.println("Amount of rooms set to 10. Printed results: "+ RP.getAmountOfRooms());
		RP.populateRoom();
		//System.out.println("Rooms Populated. Printed results: "+ RP.RM[0].getRoomNumber()+"RoomNumber\n");
		RP.customRoomSettings();
		//System.out.println("Custom Rooms Populated. Printed results: "+ RP.RM[0].INV.Gun.getQuantity()+"Gun Quantity\n");
		
		
	}
	public void setUpCharacter() {
		Player PLAYERMAIN = new Player();
		PLAYER = PLAYERMAIN;
	}
}
	

				
			
		
	

	


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-01-26 14:33:10.811
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-01-26 14:33:10.815
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2021-01-26 14:33:14.830
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.Scanner;
public class Controller {
	//Instancing

	RoomPop RP = new RoomPop(10);
	Player PLAYER = new Player();
	Scanner keyboard = new Scanner(System.in);

	//Control DATA
	int CurrentRoom = 1;
	int PreviousRoom = 0;
	String userInput;
	double Rando = Math.round((Math.random() * 1));
	
	public void getInputResponse() {
		//help,Status,Grab,inventory,search,quit,use,attack,go
		userInput = keyboard.next();
		
		//Status
		if(userInput.equalsIgnoreCase("Status")) {
			PLAYER.STATUS.sayStatus();
			}
		
		//Grab
		if(userInput.equalsIgnoreCase("Grab")) {
			
			if(RP.RM[CurrentRoom].getSearched()) {
				//FlashLight
				if(RP.RM[CurrentRoom].INV.getFlashlight()) {
					PLAYER.INV.setFlashLight(true);
					RP.RM[CurrentRoom].INV.setFlashLight(false);
					System.out.println("You grab the FlashLight");
					userInput = "";
					PLAYER.INV.setEmpty(false);
					
				}
				//keys all done manually because i'm feeling lazy
				if(RP.RM[CurrentRoom].INV.K1.getInRoom()) {
					PLAYER.INV.K1.setInInventory(true);
					RP.RM[CurrentRoom].INV.K1.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K1.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K2.getInRoom()) {
					PLAYER.INV.K2.setInInventory(true);
					RP.RM[CurrentRoom].INV.K2.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K2.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K3.getInRoom()) {
					PLAYER.INV.K3.setInInventory(true);
					RP.RM[CurrentRoom].INV.K3.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K3.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K4.getInRoom()) {
					PLAYER.INV.K4.setInInventory(true);
					RP.RM[CurrentRoom].INV.K4.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K4.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K5.getInRoom()) {
					PLAYER.INV.K5.setInInventory(true);
					RP.RM[CurrentRoom].INV.K5.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K5.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.K6.getInRoom()) {
					PLAYER.INV.K6.setInInventory(true);
					RP.RM[CurrentRoom].INV.K6.setInRoom(false);
					System.out.println("You grab the "+PLAYER.INV.K6.getKeyName());
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Lighter	
				if(RP.RM[CurrentRoom].INV.getLighter()) {
					PLAYER.INV.setLighter(true);
					RP.RM[CurrentRoom].INV.setLighter(false);
					System.out.println("You grab the Lighter");
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Gun	
				if(RP.RM[CurrentRoom].INV.Gun.getInRoom()) {
					PLAYER.INV.Gun.setQuantity(1);
					RP.RM[CurrentRoom].INV.Gun.setInRoom(false);
					System.out.println("You grab the handgun");
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Knife	
				if(RP.RM[CurrentRoom].INV.Knife.getInRoom()) {
					PLAYER.INV.Knife.setQuantity(1);
					RP.RM[CurrentRoom].INV.Knife.setInRoom(false);
					System.out.println("You grab the knife");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Salt
				if(RP.RM[CurrentRoom].INV.Salt.getInRoom()) {
					PLAYER.INV.Salt.setQuantity(1);
					RP.RM[CurrentRoom].INV.Salt.setInRoom(false);
					System.out.println("You grab the Salt");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Religious book
				if(RP.RM[CurrentRoom].INV.ReligiousBook.getInRoom()) {
					PLAYER.INV.ReligiousBook.setQuantity(1);
					RP.RM[CurrentRoom].INV.ReligiousBook.setInRoom(false);
					System.out.println("You grab the Religious Book");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//ammo
				if(RP.RM[CurrentRoom].INV.Ammo.getInRoom()) {
					PLAYER.INV.Ammo.setQuantity(12);
					RP.RM[CurrentRoom].INV.Ammo.setInRoom(false);
					System.out.println("You grab 12 rounds of handgun ammo");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				//Medicine
				if(RP.RM[CurrentRoom].INV.Medicine.getInRoom()) {
					PLAYER.INV.Medicine.setQuantity(1);
					RP.RM[CurrentRoom].INV.Medicine.setInRoom(false);
					System.out.println("You grab some medicine ");	
					userInput = "";
					PLAYER.INV.setEmpty(false);
				}
				if(RP.RM[CurrentRoom].INV.getEmpty()== true) {
					System.out.println("There is nothing here to grab");
				}
				if(RP.RM[CurrentRoom].getSearched() == false) {
				System.out.println("You havent searched the room");
				}
				RP.RM[CurrentRoom].INV.setEmpty(true);
			}
		}
		
		//inventory
		if(userInput.equalsIgnoreCase("Inventory")) {
			PLAYER.INV.sayInventory();			
		}
		
		//search
		if(userInput.equalsIgnoreCase("Search")) {
			if(RP.RM[CurrentRoom].getLight()) {
				RP.RM[CurrentRoom].setSearched(true);
				System.out.println("You searched the room");
			}else {
				System.out.println("its too dark to look around");
			}
		}
		
		//quit
		if(userInput.equalsIgnoreCase("QUIT")) {
			System.exit(0);
		}
		
		//use
		if(userInput.equalsIgnoreCase("Use")) {
			boolean USE = true;
			
			if(PLAYER.INV.getEmpty()) {
				System.out.println("you have no items to use");
				USE = false;
				userInput = "";
			}
			while(USE){
				
				System.out.println("use what");
				userInput = keyboard.nextLine();
				
				if(userInput.equalsIgnoreCase("Flashlight")) {
					RP.RM[CurrentRoom].setLight(true);
					System.out.println("the room is now lit");
					userInput = "";
					USE = false;
				}
				if(userInput.equalsIgnoreCase("cancel")) {
					userInput = "";
					USE = false;
				}
				if(userInput.equalsIgnoreCase("key")) {
					System.out.println("use key is has been tested as true moving on to the keys...");
											
					if(PLAYER.INV.K1.getInInventory()) {
						System.out.println("k1 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K1.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K1.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
					
						if(PLAYER.INV.K2.getInInventory()) {
							System.out.println("k2 in inventory is true checking if it matches the door lock value");
							
							for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
								if(PLAYER.INV.K2.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
									RP.RM[CurrentRoom].DR[i].setLocked(false);
									System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
									System.out.println("\nYou no longer need this key...");
									PLAYER.INV.K2.setInInventory(false);
									userInput = "";
									USE = false;
									}
								}
							}
						
						if(PLAYER.INV.K3.getInInventory()) {
						System.out.println("k3 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K3.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K3.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
						if(PLAYER.INV.K4.getInInventory()) {
						System.out.println("k4 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K4.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K4.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
						
						if(PLAYER.INV.K5.getInInventory()) {
						System.out.println("k5 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K5.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K5.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
						if(PLAYER.INV.K6.getInInventory()) {
						System.out.println("k6 in inventory is true checking if it matches the door lock value");
							
						for(int i = 0; i == RP.RM[CurrentRoom].getNumberOfDoors();) {
							if(PLAYER.INV.K6.getKeyValue() == RP.RM[CurrentRoom].DR[i].getlockKeyValue()&& RP.RM[CurrentRoom].DR[i].getLocked()) {
								RP.RM[CurrentRoom].DR[i].setLocked(false);
								System.out.println("Youve unlocked the "+RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.exitValue].getRoomDescription());
								System.out.println("\nYou no longer need this key...");
								PLAYER.INV.K6.setInInventory(false);
								userInput = "";
								USE = false;
								}
							}
						}
						for
						if(i == RP.RM[CurrentRoom].getNumberOfDoors() && RP.RM[CurrentRoom].DR[i].getLocked() == false){
							System.out.println("You do not have the key to unlock the door(s)");
							userInput = "";
							USE = false;
						}
					//----------------------------------------------------
					
					
					
				}
				if(userInput.equalsIgnoreCase("lighter")) {
					if(RP.RM[CurrentRoom].FP.getInRoom()) {
						
						if(PLAYER.STATUS.getSanity() >= 99) {
							System.out.println("you light the lighter but nothing happens");
						}
						if(PLAYER.STATUS.getSanity() <= 99 && RP.RM[CurrentRoom].FP.getBeenLit() == false) {
							PLAYER.STATUS.setFullSanity();
							RP.RM[CurrentRoom].FP.setBeenLit(true);
							System.out.println("you light the fireplace and you begin to feel much calmer");
						}
						if(PLAYER.STATUS.getSanity() <= 99 && RP.RM[CurrentRoom].FP.getBeenLit() == true){
							System.out.println("the room is now lightly lit. you feel more relaxed");
							PLAYER.STATUS.setSanity(5);
						}
					}
					userInput = "";
					USE = false;
				}
					
				if(userInput.equalsIgnoreCase("Gun") || userInput.equalsIgnoreCase("Knife")||
						userInput.equalsIgnoreCase("Salt")||userInput.equalsIgnoreCase("Book")||userInput.equalsIgnoreCase("Ammo") ) {
					System.out.println("now is not the time to use it");
					userInput = "";
					USE = false;
				}

				if(userInput.equalsIgnoreCase("medicine")) {
					
					if(PLAYER.STATUS.getHealth() < 100){
						PLAYER.STATUS.setHealth(PLAYER.INV.Medicine.getDamage());
						PLAYER.INV.Medicine.setQuantity(-1);
						System.out.println("you feel a bit better");
						userInput = "";
						USE = false;						
					}
					
					if(PLAYER.STATUS.getHealth()== 100) {
		 				System.out.println("now is not the time to use it");
						userInput = "";
						USE = false;
					}					
					
				}				
				
			}
  
		}
		
		
		if(userInput.equalsIgnoreCase("Attack")) {

			if(RP.RM[CurrentRoom].getNumberOfEnemies() <= 0) {
				System.out.println("there is nothing here to attack.");
			}
			
			while(RP.RM[CurrentRoom].getNumberOfEnemies() >= 1) {
				boolean Attack = true;
				boolean PlayerAttack = true;
				boolean EnemyAttack = false;
				
				Ghost GHOST = new Ghost(); //0 for ghost 
				Figure FIGURE = new Figure();//1 for figure
				System.out.println("Number of enemies in room " + RP.RM[CurrentRoom].getNumberOfEnemies());
				
				while(Attack) {					
					if(GHOST.STATUS.getHealth() <= 0) {
						RP.RM[CurrentRoom].setNumberOfEnemies(0);
						System.out.println("There are no longer enemies in the room" );
						userInput = "";
						Attack = false;
						break;
					}
					if(FIGURE.STATUS.getHealth() <= 0) {
						RP.RM[CurrentRoom].setNumberOfEnemies(0);
						System.out.println("There are no longer enemies in the room" );
						userInput = "";
						Attack = false;
						break;
					}
					if(PLAYER.STATUS.getSanity() <= 0 || PLAYER.STATUS.getHealth() <= 0) {//Game over with score printed
						
					}
					if(PlayerAttack == true) {					
						System.out.println("You begin to attack the " + RP.RM[CurrentRoom].getEnemyName() +". what do you attack with.");
						PLAYER.STATUS.sayStatus();
						userInput = keyboard.next();

							if(userInput.equalsIgnoreCase("Gun") && PLAYER.INV.Gun.getQuantity() == 1 && PLAYER.INV.Ammo.getQuantity() >=1 ) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You shoot the Ghost. However the bullet passes right through it.");
									PLAYER.INV.Ammo.setQuantity(-1);
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You shoot the Figure. The Figure lurches back in pain.");
									PLAYER.INV.Ammo.setQuantity(-1);
									FIGURE.STATUS.setHealth(PLAYER.INV.Gun.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Knife") && PLAYER.INV.Knife.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You slash at the Ghost. However nothing happens.");
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You slash at the Figure. The Figure dashes back in pain.");
									FIGURE.STATUS.setHealth(PLAYER.INV.Knife.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Salt") && PLAYER.INV.Salt.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You throw a fist full of salt at the ghost. You see it recoil in pain.");
									GHOST.STATUS.setHealth(PLAYER.INV.Salt.getDamage());
									System.out.println("Ghost HP: "+GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You throw a fist full of salt at the Figure. it barely flintches ");
									FIGURE.STATUS.setHealth(PLAYER.INV.Salt.getDamage());
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							
							if(userInput.equalsIgnoreCase("Book") && PLAYER.INV.ReligiousBook.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You read from the book. The Ghost Howls in pain");
									GHOST.STATUS.setHealth(PLAYER.INV.ReligiousBook.getDamage());
									System.out.println(GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You Read from the book. The figure Paces unfazed");
									PlayerAttack = false;
									EnemyAttack = true;
								}
							}
							if(userInput.equalsIgnoreCase("FingerGuns")  && PLAYER.INV.FingerGun.getQuantity() == 1) {
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									System.out.println("You slowly make a gun with your fingers, the ghost laughs at you. as you drop the thumb hammer \nthe ghost instantly begins to shake violently and finally it gets ripped appart atom by atom");
									GHOST.STATUS.setHealth(PLAYER.INV.FingerGun.getDamage());
									System.out.println("Ghost HP: "+GHOST.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									System.out.println("You slowly make a gun with your fingers, the figure laughs at you. as you drop the thumb hammer \nthe figure stops in its tracks, blood begins to pour from its orifaces and soon its entire body begins to colapse inward on itself as if a black hole appeared within its stomach.");
									FIGURE.STATUS.setHealth(PLAYER.INV.FingerGun.getDamage());
									System.out.println("Figure HP: "+FIGURE.STATUS.getHealth());
									PlayerAttack = false;
									EnemyAttack = true;
								}	
							}
							if(userInput.equalsIgnoreCase("Run")){
								
								if(RP.RM[CurrentRoom].getEnemyType() == 0) {
									PLAYER.STATUS.setSanity(GHOST.INV.GhostAttack.getDamage());
									System.out.println("The Ghost Drains your sanity, but you managed to escape.");
									CurrentRoom = PreviousRoom;
									Attack = false;
									break;
								}
								if(RP.RM[CurrentRoom].getEnemyType() == 1) {
									PLAYER.STATUS.setHealth(FIGURE.INV.FigureAttack.getDamage());
									System.out.println("The Figure Attacks you, but you managed to escape.");
									CurrentRoom = PreviousRoom;
									Attack = false;
									break;
								}
							}
						}
							
						while(EnemyAttack = true) {
							if(RP.RM[CurrentRoom].getEnemyType() == 0 && GHOST.STATUS.getHealth() >= 1) {
								PLAYER.STATUS.setSanity(GHOST.INV.GhostAttack.getDamage());
								System.out.println("The Ghost Drains your sanity");
								EnemyAttack = false;
								PlayerAttack = true;
							}
							if(RP.RM[CurrentRoom].getEnemyType() == 1 && FIGURE.STATUS.getHealth() >= 1) {
								PLAYER.STATUS.setHealth(FIGURE.INV.FigureAttack.getDamage());
								System.out.println("The Figure Attacks you.");
								EnemyAttack = false;
								PlayerAttack = true;
							}
							break;
						}
							
					
						
					}
					break;
				}
		}
					
				
			
	
		//Help
		if(userInput.equalsIgnoreCase("help")) {
			System.out.println("commands: help,Status,Grab,inventory,search,quit,use,attack,Go");
		}
		
		//Go
		if(userInput.equalsIgnoreCase("Go")) {
			
			if(RP.RM[CurrentRoom].getNumberOfEnemies() >= 1)
			{
				System.out.println("something blocks the door");

				
			}else {
			
			System.out.println("Go where? ");
			
			for(int i = 0; i <= RP.RM[CurrentRoom].getNumberOfDoors();i++ ) {
				System.out.println(RP.RM[RP.RM[CurrentRoom].DR[i].EXIT.getExitValue()].getRoomDescription());	
			}
			
			//System.out.println(RP.RM[0].getRoomDescription());
			
			userInput = keyboard.nextLine();
			userInput = keyboard.nextLine();
			
			boolean Searching = true;
			while(Searching == true) {
				for (int i = 0; i < RP.AmountOfRooms;) { // for the ammount of rooms made search them all
					
					//System.out.println(userInput);
					//System.out.println("Checking "+RP.RM[i].getRoomDescription());
					if(RP.RM[i].getRoomDescription() == null) { //if there is no description, then there's probably no room so stop tryin'
						Searching = false;
						break;
					}
					if(RP.RM[i].getRoomDescription().equalsIgnoreCase(userInput)) { // testing user string room name matches the room being searched.
						
					//	System.out.println("Room Description matched true now searching door values....");
						for (int b = 0; b <= RP.RM[CurrentRoom].getNumberOfDoors();) { //if user input matches a room, then for each door in the room check each door for:
							
							//System.out.println("currently the room were searching. ( "+ RP.RM[i].getRoomDescription() + ") door being searched ( " + b +" )...");  // help debug any room issues
							//System.out.println("Now testing if ( "+ RP.RM[CurrentRoom].getRoomDescription() + " ) room Door ("+b+") to see if room ( \""+i+" "+RP.RM[i].getRoomDescription()+"\") room number matches the searched door exit value. and if room ( \""+RP.RM[i].getRoomDescription()+"\" ) door ( "+b+" ) is locked....");
							
							if(RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() == RP.RM[i].getRoomNumber() && RP.RM[CurrentRoom].DR[b].getLocked() == false) { //if our current room's door exit leads to the room were checking and if its not locked then change our current room to the new room being searched.
								System.out.println("You are at the "+RP.RM[i].getRoomDescription());
								PreviousRoom = CurrentRoom;
								CurrentRoom = RP.RM[i].getRoomNumber();
								userInput = "";
								Searching = false;
								break;
							}
						//	System.out.println("now testing if room is accessable from current location....");
							 //b == RP.RM[CurrentRoom].getNumberOfDoors() 
							if(b == RP.RM[CurrentRoom].getNumberOfDoors() && RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() != RP.RM[i].getRoomNumber()) { // if our current room, and all its doors exits dont match the room were searching, and their door exit values then we cannot go to that room from where we are.
								System.out.println("you cannot go to that room from here.");
								userInput = "";
								Searching = false;
								break;
							}
						//	System.out.println("pretty much testing what the first check was testing but now has a diffrent action if door is locked...");
							
							if(RP.RM[CurrentRoom].DR[b].EXIT.getExitValue() == RP.RM[i].getRoomNumber() && RP.RM[CurrentRoom].DR[b].getLocked() == true) { //if our current room's door exit leads to the room were checking and if its locked then say its locked. 
								System.out.println("the room is locked");
								userInput = "";
								Searching = false;
								break;
							}
							
							 else {
						//		System.out.println("door ( "+b+" ) did not match the the room trying a new door...\n");
								b++;
							}
						}

					}else {
						i++;
						}
					}
				}
			

			}
		}
		
		//dev tools
		if(userInput.equalsIgnoreCase("DevRoomNumber")) {
			System.out.println(CurrentRoom);
			}
		if(userInput.equalsIgnoreCase("DevRoomNumberOfExits")) {
			System.out.println(RP.RM[CurrentRoom].getNumberOfDoors());
			}
		if(userInput.equalsIgnoreCase("LendLease")) {
			System.out.println("The united states government has provided you with assistance for this mission.");
			PLAYER.INV.Ammo.setQuantity(1200);
			PLAYER.INV.Medicine.setQuantity(1200);
			PLAYER.INV.Gun.setQuantity(1);
			PLAYER.INV.ReligiousBook.setQuantity(1);
			PLAYER.INV.FingerGun.setQuantity(1);
			
			}
		if(userInput.equalsIgnoreCase("lockpick")) {
			System.out.println("who wouldnt bring a lock pick to a mansion");
			PLAYER.INV.K1.setInInventory(true);
			PLAYER.INV.K2.setInInventory(true);
			PLAYER.INV.K3.setInInventory(true);
			PLAYER.INV.K4.setInInventory(true);
			PLAYER.INV.K5.setInInventory(true);
			PLAYER.INV.K6.setInInventory(true);
			PLAYER.INV.setEmpty(false);
			}
	}
	
	
	

	public void setUserInput(String UI) {
		userInput = UI;
		
	}
	public void setUpRooms() {
		RP.setAmountOfRooms(25);
		//System.out.println("Amount of rooms set to 10. Printed results: "+ RP.getAmountOfRooms());
		RP.populateRoom();
		//System.out.println("Rooms Populated. Printed results: "+ RP.RM[0].getRoomNumber()+"RoomNumber\n");
		RP.customRoomSettings();
		//System.out.println("Custom Rooms Populated. Printed results: "+ RP.RM[0].INV.Gun.getQuantity()+"Gun Quantity\n");
		
		
	}
	public void setUpCharacter() {
		Player PLAYERMAIN = new Player();
		PLAYER = PLAYERMAIN;
	}
}
	

				
			
		
	

	


----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2021-01-26 14:33:14.835
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2021-01-26 14:33:14.841
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:880)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2011)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3764)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1932)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1963)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToExpression(ASTConverter.java:3616)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2174)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2965)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3415)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3015)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1372)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2944)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2203)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2968)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3316)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1513)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:474)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:200)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:596)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1141)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1318)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.access$0(JavaReconcilingStrategy.java:113)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)
!SESSION 2021-01-26 15:42:11.210 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-26 15:42:22.471
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-26 15:42:22.471
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7977f046,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6ec98ccc,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-26 15:42:29.655
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-27 09:51:57.926 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-27 09:52:24.839
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-27 09:52:24.839
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f17dd06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7977f046,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-27 09:52:31.728
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-28 10:23:17.676 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-28 10:23:25.478
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-28 10:23:25.478
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3d02ff64,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f17dd06,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-28 10:23:32.108
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-29 09:42:05.902 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-29 09:42:14.838
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-29 09:42:14.838
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@46fa2a7e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3d02ff64,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-29 09:42:21.635
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-30 19:46:05.460 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-30 19:46:13.385
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-30 19:46:13.385
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@67b3960b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@415262a0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-30 19:46:20.136
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-01-31 08:52:11.544 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-31 08:52:30.726
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-31 08:52:30.726
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@68360fb9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1c787389,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-31 08:52:37.007
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2021-01-31 10:37:34.236
!MESSAGE Unhandled event loop exception
!STACK 0
java.lang.ClassCastException: class org.eclipse.jdt.internal.corext.fix.LinkedProposalPositionGroupCore cannot be cast to class org.eclipse.jdt.internal.corext.fix.LinkedProposalPositionGroup (org.eclipse.jdt.internal.corext.fix.LinkedProposalPositionGroupCore is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @6b6f73d; org.eclipse.jdt.internal.corext.fix.LinkedProposalPositionGroup is in unnamed module of loader org.eclipse.osgi.internal.loader.EquinoxClassLoader @4a013b23)
	at org.eclipse.jdt.internal.corext.fix.LinkedProposalModel$LinkedProposalPositionGroupIterator.next(LinkedProposalModel.java:47)
	at org.eclipse.jdt.internal.corext.fix.LinkedProposalModel$LinkedProposalPositionGroupIterator.next(LinkedProposalModel.java:1)
	at org.eclipse.jdt.internal.ui.viewsupport.LinkedProposalModelPresenter.enterLinkedMode(LinkedProposalModelPresenter.java:75)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.LinkedCorrectionProposal.performChange(LinkedCorrectionProposal.java:161)
	at org.eclipse.jdt.ui.text.java.correction.CUCorrectionProposal.apply(CUCorrectionProposal.java:167)
	at org.eclipse.jdt.internal.ui.text.correction.proposals.FixCorrectionProposal.apply(FixCorrectionProposal.java:181)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.apply(AbstractAnnotationHover.java:556)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.access$1(AbstractAnnotationHover.java:538)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl$4.widgetSelected(AbstractAnnotationHover.java:532)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:252)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4209)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1037)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1061)
	at org.eclipse.swt.widgets.Widget.sendSelectionEvent(Widget.java:1078)
	at org.eclipse.swt.widgets.Link.wmNotifyChild(Link.java:713)
	at org.eclipse.swt.widgets.Control.wmNotify(Control.java:5816)
	at org.eclipse.swt.widgets.Composite.wmNotify(Composite.java:1954)
	at org.eclipse.swt.widgets.Control.WM_NOTIFY(Control.java:5384)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4818)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4938)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Link.callWindowProc(Link.java:161)
	at org.eclipse.swt.widgets.Widget.wmLButtonUp(Widget.java:1964)
	at org.eclipse.swt.widgets.Control.WM_LBUTTONUP(Control.java:5197)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4799)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:4930)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3624)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:00:32.559
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:04:24.817
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:05:27.270
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:12:28.483
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:12:53.524
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:13:31.993
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:13:48.118
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:14:09.038
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:14:51.853
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:15:05.616
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:16:51.524
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:18:12.808
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:18:51.823
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:19:01.156
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:20:25.513
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:25:12.157
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:25:19.671
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 11:39:56.282
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 12:04:42.868
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 12:04:50.224
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 12:31:34.773
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 12:31:42.133
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 12:51:37.189
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 12:52:36.985
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 12:54:32.537
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)

!ENTRY org.eclipse.ui.workbench.texteditor 4 0 2021-01-31 13:01:04.334
!MESSAGE 
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.ui.texteditor.ITextEditor.isDirty()" because "this.fTextEditor" is null
	at org.eclipse.ui.texteditor.AbstractTextEditor$TextEditorSavable.isDirty(AbstractTextEditor.java:7165)
	at org.eclipse.ui.internal.Workbench.getFilteredSaveables(Workbench.java:3447)
	at org.eclipse.ui.internal.Workbench.saveAll(Workbench.java:3420)
	at org.eclipse.ui.ide.IDE$1.run(IDE.java:1494)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.ui.ide.IDE.saveAllEditors(IDE.java:1482)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.doSave(SaveScopeResourcesHandler.java:228)
	at org.eclipse.debug.internal.ui.launchConfigurations.SaveScopeResourcesHandler.handleStatus(SaveScopeResourcesHandler.java:182)
	at org.eclipse.debug.internal.ui.sourcelookup.Prompter.lambda$0(Prompter.java:73)
	at org.eclipse.ui.internal.PendingSyncExec.run(PendingSyncExec.java:68)
	at org.eclipse.ui.internal.UILockListener.doPendingWork(UILockListener.java:171)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4001)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3629)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1157)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1046)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:134)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:64)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:564)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:653)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:590)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1461)
!SESSION 2021-01-31 14:00:32.639 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-01-31 14:00:39.244
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-01-31 14:00:39.244
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f19d423,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73958426,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-01-31 14:00:44.156
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-01 08:45:20.021 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-01 08:45:34.321
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-01 08:45:34.321
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@23933031,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4d0b7fd5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-01 08:45:44.165
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-01 09:54:29.402 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-01 09:54:38.981
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-01 09:54:38.981
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@43090195,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7921a37d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-01 09:54:45.012
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-01 09:59:39.748 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-01 09:59:44.131
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-01 09:59:44.131
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1ce2029b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@43090195,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-01 09:59:49.561
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-01 10:05:06.837 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-01 10:05:14.817
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-01 10:05:14.817
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@225ddf5f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@51468039,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-01 10:05:18.879
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.epp.mpc.ui 4 0 2021-02-01 10:11:25.524
!MESSAGE Problems occurred while performing provisioning operation: operation plan must be resolved
!STACK 0
java.lang.IllegalStateException: operation plan must be resolved
	at org.eclipse.equinox.internal.p2.ui.ProvUI.toCurrentJREOperation(ProvUI.java:338)
	at org.eclipse.equinox.internal.p2.ui.ProvUI.toCompabilityWithCurrentJREProvisioningPlan(ProvUI.java:325)
	at org.eclipse.epp.internal.mpc.ui.wizards.MarketplaceWizard.lambda$5(MarketplaceWizard.java:876)
	at org.eclipse.jface.operation.ModalContext$ModalContextThread.run(ModalContext.java:122)
!SESSION 2021-02-01 10:18:11.570 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-01 10:18:19.981
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-01 10:18:19.981
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7d8d671b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@28b68067,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-01 10:18:25.615
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-03 13:05:49.771 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-03 13:06:16.118
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-03 13:06:16.118
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@416c1b0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@363ba634,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-03 13:06:21.100
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-03 21:51:37.716 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-03 21:51:42.724
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-03 21:51:42.724
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1bba9862,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@451a4187,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-03 21:51:46.800
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-03 22:23:59.609 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-03 22:24:09.502
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-03 22:24:09.502
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@565c887e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c215642,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-03 22:24:14.025
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-04 10:04:56.656 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-04 10:14:41.730
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-04 10:14:41.730
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@451a4187,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@565c887e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-04 10:14:45.959
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-05 10:46:13.443 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-05 10:46:51.676
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-05 10:46:51.676
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@451a4187,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@565c887e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-05 10:46:56.564
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-06 13:07:52.509 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-06 13:09:00.550
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-06 13:09:00.550
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@38197e82,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5516ee5,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-06 13:09:05.021
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-06 17:12:51.801 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2021-02-06 17:13:11.660
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2021-02-06 17:13:13.232
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-06 17:13:13.232
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@318511f0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@53564a4c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-06 17:13:17.425
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.debug.ui 4 120 2021-02-06 17:37:07.230
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2021-02-06 21:43:27.066 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-06 21:43:32.117
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-06 21:43:32.117
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c215642,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1317ac2c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-06 21:43:36.616
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-07 10:25:18.174 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-07 10:25:23.995
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-07 10:25:23.996
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@565c887e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c215642,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-07 10:25:28.438
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-07 21:41:56.976 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-07 21:42:02.699
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-07 21:42:02.699
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@565c887e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c215642,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-07 21:42:07.239
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-08 15:08:11.854 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-08 15:08:40.096
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-08 15:08:40.096
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@565c887e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c215642,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-08 15:08:44.506
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-09 09:13:08.126 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-09 09:14:46.530
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-09 09:14:46.530
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5c215642,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1317ac2c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-09 09:14:50.558
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-10 09:32:56.479 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-10 09:33:26.707
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-10 09:33:26.707
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1317ac2c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@416c1b0,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-10 09:33:32.440
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.debug.ui 4 120 2021-02-10 09:57:48.861
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)

!ENTRY org.eclipse.core.resources 4 567 2021-02-10 10:49:32.126
!MESSAGE The project description file (.project) for 'V3' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'V3' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.core.resources 4 567 2021-02-10 12:55:00.334
!MESSAGE The project description file (.project) for 'V3' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
!STACK 0
java.lang.Exception: The project description file (.project) for 'V3' is missing.  This file contains important information about the project.  The project will not function properly until this file is restored.
	at org.eclipse.core.internal.resources.ResourceException.provideStackTrace(ResourceException.java:42)
	at org.eclipse.core.internal.resources.ResourceException.<init>(ResourceException.java:38)
	at org.eclipse.core.internal.localstore.FileSystemResourceManager.read(FileSystemResourceManager.java:908)
	at org.eclipse.core.internal.resources.SaveManager.restoreMetaInfo(SaveManager.java:888)
	at org.eclipse.core.internal.resources.SaveManager.restore(SaveManager.java:763)
	at org.eclipse.core.internal.resources.Project.open(Project.java:1060)
	at org.eclipse.ui.actions.OpenResourceAction$1.doOpenWithReferences(OpenResourceAction.java:233)
	at org.eclipse.ui.actions.OpenResourceAction$1.runInWorkspace(OpenResourceAction.java:279)
	at org.eclipse.core.internal.resources.InternalWorkspaceJob.run(InternalWorkspaceJob.java:42)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2021-02-11 10:43:38.888 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-11 10:44:57.382
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-11 10:44:57.382
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ce4498f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f7557fe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-11 10:45:02.136
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.debug.ui 4 120 2021-02-11 11:39:16.876
!MESSAGE Error logged from Debug UI: 
!STACK 0
java.lang.InterruptedException
	at java.base/java.util.concurrent.FutureTask.awaitDone(FutureTask.java:418)
	at java.base/java.util.concurrent.FutureTask.get(FutureTask.java:203)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.runInUIThreadWithTimeout(SelectedResourceManager.java:262)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getFromUI(SelectedResourceManager.java:240)
	at org.eclipse.debug.internal.ui.stringsubstitution.SelectedResourceManager.getActiveWindow(SelectedResourceManager.java:231)
	at org.eclipse.debug.ui.DebugUITools.getDebugContext(DebugUITools.java:247)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getFrame(JavaDebugHover.java:97)
	at org.eclipse.jdt.internal.debug.ui.JavaDebugHover.getHoverInfo2(JavaDebugHover.java:251)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:163)
	at org.eclipse.jdt.internal.ui.text.java.hover.BestMatchHover.getHoverInfo2(BestMatchHover.java:130)
	at org.eclipse.jdt.internal.ui.text.java.hover.JavaEditorTextHoverProxy.getHoverInfo2(JavaEditorTextHoverProxy.java:89)
	at org.eclipse.jface.text.TextViewerHoverManager$1.run(TextViewerHoverManager.java:155)
!SESSION 2021-02-11 15:36:54.101 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-11 15:36:59.162
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-11 15:36:59.162
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ce4498f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f7557fe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-11 15:37:03.846
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-12 10:25:13.195 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-12 10:25:46.323
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-12 10:25:46.323
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@363ba634,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@60fe75f7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-12 10:25:50.434
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-12 20:58:02.182 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-12 20:58:07.746
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-12 20:58:07.746
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c6ab057,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ce4498f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-12 20:58:14.093
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2021-02-13 17:19:39.729 -----------------------------------------------
eclipse.buildId=4.18.0.I20201202-1800
java.version=15.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2021-02-13 17:19:58.615
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2021-02-13 17:19:58.615
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7ce4498f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f7557fe,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2021-02-13 17:20:04.100
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\austi'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
